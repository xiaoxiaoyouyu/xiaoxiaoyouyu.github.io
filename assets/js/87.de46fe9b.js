(window.webpackJsonp=window.webpackJsonp||[]).push([[87],{388:function(t,a,e){"use strict";e.r(a);var v=e(0),i=Object(v.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h2",{attrs:{id:"实验名称-进程调度"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#实验名称-进程调度"}},[t._v("#")]),t._v(" 实验名称：进程调度")]),t._v(" "),e("ul",[e("li",[t._v("实验学时：2学时")])]),t._v(" "),e("hr"),t._v(" "),e("h2",{attrs:{id:"预习报告-2021-05-12"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#预习报告-2021-05-12"}},[t._v("#")]),t._v(" 预习报告 2021-05-12")]),t._v(" "),e("h4",{attrs:{id:"实验原理摘要"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#实验原理摘要"}},[t._v("#")]),t._v(" 实验原理摘要")]),t._v(" "),e("ul",[e("li",[t._v("先来先服务的调度算法：最简单的调度算法，当作业调度中采用该算法时，系统将按照作业到达的先后次序来进行调度，优先从后备队列中，选择一个或多个位于队列头部的作业，把他们调入内存，分配所需资源、创建进程，然后放入“就绪队列”,直到该进程运行到完成或发生某事件堵塞后，进程调度程序才将处理机分配给其他进程。")])]),t._v(" "),e("h4",{attrs:{id:"实验仪器"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#实验仪器"}},[t._v("#")]),t._v(" 实验仪器")]),t._v(" "),e("ul",[e("li",[t._v("编程环境：Visual C++6.0环境下的C语言")]),t._v(" "),e("li",[t._v("操作系统软件：windows 7")])]),t._v(" "),e("h4",{attrs:{id:"实验内容及步骤"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#实验内容及步骤"}},[t._v("#")]),t._v(" 实验内容及步骤")]),t._v(" "),e("ol",[e("li",[t._v("设计一个先来先服务调度的算法")]),t._v(" "),e("li",[t._v("对选定的调度算法编程实现。")]),t._v(" "),e("li",[t._v("对选定的调度算法进行描述（包括数据结构即进程控制块的描述和算法步骤描述）描述算法时可以采用自然语言、可以画流程图也可以使用伪码。将算法描述写入预习报告")])]),t._v(" "),e("hr"),t._v(" "),e("h2",{attrs:{id:"实验报告-2021-05-13"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#实验报告-2021-05-13"}},[t._v("#")]),t._v(" 实验报告 2021-05-13")]),t._v(" "),e("h4",{attrs:{id:"实验目的及要求"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#实验目的及要求"}},[t._v("#")]),t._v(" 实验目的及要求：")]),t._v(" "),e("ol",[e("li",[t._v("进程调度是处理机管理的核心内容。")]),t._v(" "),e("li",[t._v("通过本实验可以加深理解有关进程控制块、进程队列的概念，并体会和了解优先数和时间片轮转调度算法的具体实施办法。")]),t._v(" "),e("li",[t._v("本实验要求用C语言编写和调试一个简单的进程调度程序。")])]),t._v(" "),e("h4",{attrs:{id:"实验环境"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#实验环境"}},[t._v("#")]),t._v(" 实验环境")]),t._v(" "),e("ul",[e("li",[t._v("编辑器: VSCode")]),t._v(" "),e("li",[t._v("编程环境: GCC 4.8.1")]),t._v(" "),e("li",[t._v("操作系统软件: Windows 10")])]),t._v(" "),e("h4",{attrs:{id:"实验内容"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#实验内容"}},[t._v("#")]),t._v(" 实验内容")]),t._v(" "),e("ol",[e("li",[t._v("设计一个先来先服务调度的算法")]),t._v(" "),e("li",[t._v("对选定的调度算法编程实现。")]),t._v(" "),e("li",[t._v("对选定的调度算法进行描述（包括数据结构即进程控制块的描述和算法步骤描述）描述算法时可以采用自然语言、可以画流程图也可以使用伪码。将算法描述写入预习报告")])]),t._v(" "),e("h4",{attrs:{id:"实验步骤"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#实验步骤"}},[t._v("#")]),t._v(" 实验步骤")]),t._v(" "),e("ol",[e("li",[e("p",[t._v("首先定义一个结构体,用于保存一个进程的各种信息")]),t._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("struct pcb {\n    char name[10], state; \n    int ntime, rtime, vtime; \n    struct pcb* link;\n}*ready = 0, *p; \n")])])])]),t._v(" "),e("li",[e("p",[t._v("以下为主要模块")]),t._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("void sort();    // 建立对进程进行先来先服务排列函数，先来的放在队头，行成一个带头结点的链表队列\nvoid input();   // 建立进程控制块函数，输入测试用例\nvoid space();   // 统计就绪程序数目\nvoid disp();    // 显示进程当前状态\nvoid check();   // 查看进程\nvoid destory(); // 进程撤销函数，用于进程运行结束，撤销进程\nvoid running(); // 进程运行函数\nint main(void); // 主函数\n")])])])]),t._v(" "),e("li",[e("p",[t._v("主要代码(进程运行函数)")]),t._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("void running() { \n    (p->rtime)++; \n    if(p->rtime == p->ntime) {\n        destroy();\n    } else { \n        p->state = 'w'; \n        sort();\n    } \n} \n")])])])])]),t._v(" "),e("h4",{attrs:{id:"实验结果"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#实验结果"}},[t._v("#")]),t._v(" 实验结果")]),t._v(" "),e("ol",[e("li",[e("p",[t._v("测试用例")]),t._v(" "),e("table",[e("thead",[e("tr",[e("th",{staticStyle:{"text-align":"center"}},[t._v("进程名称")]),t._v(" "),e("th",{staticStyle:{"text-align":"center"}},[t._v("A")]),t._v(" "),e("th",{staticStyle:{"text-align":"center"}},[t._v("B")]),t._v(" "),e("th",{staticStyle:{"text-align":"center"}},[t._v("C")]),t._v(" "),e("th",{staticStyle:{"text-align":"center"}},[t._v("D")]),t._v(" "),e("th",{staticStyle:{"text-align":"center"}},[t._v("E")])])]),t._v(" "),e("tbody",[e("tr",[e("td",{staticStyle:{"text-align":"center"}},[t._v("到达时间")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("0")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("1")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("2")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("3")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("4")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"center"}},[t._v("服务时间")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("4")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("3")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("5")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("2")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("4")])])])])]),t._v(" "),e("li",[e("p",[t._v("结果\n"),e("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/Nightliuguoxing/Pic@main/image/os/1621332111422-OSOP201.jpg",alt:"最开始"}}),t._v(" "),e("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/Nightliuguoxing/Pic@main/image/os/1621332122130-OSOP202.jpg",alt:"运行中···"}})])])]),t._v(" "),e("h4",{attrs:{id:"总结"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),e("ul",[e("li",[t._v("通过这次实验，加深了对进程的理解，同时掌握了进程控制块的结构，理解了进程的运行的并发性。")])])])}),[],!1,null,null,null);a.default=i.exports}}]);