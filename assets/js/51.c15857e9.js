(window.webpackJsonp=window.webpackJsonp||[]).push([[51],{352:function(t,a,_){"use strict";_.r(a);var v=_(0),r=Object(v.a)({},(function(){var t=this,a=t.$createElement,_=t._self._c||a;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h2",{attrs:{id:"绪论"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#绪论"}},[t._v("#")]),t._v(" 绪论")]),t._v(" "),_("h2",{attrs:{id:"学习资源"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#学习资源"}},[t._v("#")]),t._v(" 学习资源")]),t._v(" "),_("p",[_("a",{attrs:{href:"https://www.yuque.com/attachments/yuque/0/2020/pdf/2579946/1600566131571-28b35bb1-828b-422b-ab77-aad5086a966f.pdf?_lake_card=%7B%22uid%22%3A%221600566130838-0%22%2C%22src%22%3A%22https%3A%2F%2Fwww.yuque.com%2Fattachments%2Fyuque%2F0%2F2020%2Fpdf%2F2579946%2F1600566131571-28b35bb1-828b-422b-ab77-aad5086a966f.pdf%22%2C%22name%22%3A%22101%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.pdf%22%2C%22size%22%3A662909%2C%22type%22%3A%22application%2Fpdf%22%2C%22ext%22%3A%22pdf%22%2C%22progress%22%3A%7B%22percent%22%3A99%7D%2C%22status%22%3A%22done%22%2C%22percent%22%3A0%2C%22id%22%3A%22FB8X3%22%2C%22card%22%3A%22file%22%7D",target:"_blank",rel:"noopener noreferrer"}},[t._v("101什么是数据结构.pdf"),_("OutboundLink")],1),_("br"),t._v(" "),_("a",{attrs:{href:"https://www.yuque.com/attachments/yuque/0/2020/pdf/2579946/1600566143143-41bb9b69-754a-4e78-9588-d5b23abaca57.pdf?_lake_card=%7B%22uid%22%3A%221600566141343-0%22%2C%22src%22%3A%22https%3A%2F%2Fwww.yuque.com%2Fattachments%2Fyuque%2F0%2F2020%2Fpdf%2F2579946%2F1600566143143-41bb9b69-754a-4e78-9588-d5b23abaca57.pdf%22%2C%22name%22%3A%22102%E5%88%9D%E8%AF%86%E7%AE%97%E6%B3%95.pdf%22%2C%22size%22%3A858780%2C%22type%22%3A%22application%2Fpdf%22%2C%22ext%22%3A%22pdf%22%2C%22progress%22%3A%7B%22percent%22%3A99%7D%2C%22status%22%3A%22done%22%2C%22percent%22%3A0%2C%22id%22%3A%221s9ZB%22%2C%22card%22%3A%22file%22%7D",target:"_blank",rel:"noopener noreferrer"}},[t._v("102初识算法.pdf"),_("OutboundLink")],1),_("br"),t._v(" "),_("a",{attrs:{href:"https://www.yuque.com/attachments/yuque/0/2020/pdf/2579946/1601539828758-786f9956-5bca-4705-ad89-4be5b16f9d47.pdf?_lake_card=%7B%22uid%22%3A%221601539827697-0%22%2C%22src%22%3A%22https%3A%2F%2Fwww.yuque.com%2Fattachments%2Fyuque%2F0%2F2020%2Fpdf%2F2579946%2F1601539828758-786f9956-5bca-4705-ad89-4be5b16f9d47.pdf%22%2C%22name%22%3A%22103%E7%AE%97%E6%B3%95%E6%95%88%E7%8E%87%E7%9A%84%E8%A1%A1%E9%87%8F%E5%92%8C%E8%AF%84%E4%BB%B7.pdf%22%2C%22size%22%3A1118701%2C%22type%22%3A%22application%2Fpdf%22%2C%22ext%22%3A%22pdf%22%2C%22progress%22%3A%7B%22percent%22%3A99%7D%2C%22status%22%3A%22done%22%2C%22percent%22%3A0%2C%22id%22%3A%22ZgTAj%22%2C%22card%22%3A%22file%22%7D",target:"_blank",rel:"noopener noreferrer"}},[t._v("103算法效率的衡量和评价.pdf"),_("OutboundLink")],1),_("br")]),t._v(" "),_("h2",{attrs:{id:"学习笔记"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#学习笔记"}},[t._v("#")]),t._v(" 学习笔记")]),t._v(" "),_("h3",{attrs:{id:"_1-1什么是数据结构"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-1什么是数据结构"}},[t._v("#")]),t._v(" 1.1什么是数据结构")]),t._v(" "),_("p",[t._v("例子:")]),t._v(" "),_("ul",[_("li",[t._v("图书馆的书目检索系统自动化问题")]),t._v(" "),_("li",[t._v("计算机和人对弈问题")]),t._v(" "),_("li",[t._v("多叉路口交通灯的管理问题")])]),t._v(" "),_("p",[_("code",[t._v("算法 + 数据结构 = 程序")]),t._v(" "),_("code",[t._v("Alogorithm + DataStructures = Programs")])]),t._v(" "),_("h3",{attrs:{id:"_1-2-基本概念和术语"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-基本概念和术语"}},[t._v("#")]),t._v(" 1.2 基本概念和术语")]),t._v(" "),_("ul",[_("li",[t._v("数据：是对客观事物的符号表示\n"),_("ul",[_("li",[t._v("数据是信息的载体，是描述客观事物的数、字符、以及所有能输入到计算机中，被计算机程序识别和处理的符号的集合。")]),t._v(" "),_("li",[t._v("是计算机操作的对象的总称。")]),t._v(" "),_("li",[t._v("是计算机处理的信息的某种特定的符号表示形式。")])])]),t._v(" "),_("li",[_("code",[t._v("数据元素")]),t._v("：\n"),_("ul",[_("li",[t._v("是数据的"),_("code",[t._v("基本单位")])]),t._v(" "),_("li",[t._v('是数据（集合）中的一个"个体"')])])]),t._v(" "),_("li",[_("code",[t._v("数据项")]),t._v("：数据项是构成数据元素的不可分割的"),_("code",[t._v("最小单位")]),t._v(" "),_("ul",[_("li",[t._v("一个数据元素可以由若干个数据项组成")]),t._v(" "),_("li",[t._v("是组成数据元素的、具有独立含义的、不可分割的最小单位")])])]),t._v(" "),_("li",[t._v("数据对象：是性质相同的数据元素的集合，是数据的一个子集")]),t._v(" "),_("li",[t._v("数据结构：\n"),_("ul",[_("li",[t._v('数据结构是一门讨论"描述现实世界实体的数学模型(非数值计算)及其上的操作在计算机中如何表示和实现"的学科。->['),_("code",[t._v("概括的说")]),t._v("]")]),t._v(" "),_("li",[t._v("是带结构的数据元素的集合")]),t._v(" "),_("li",[t._v("是相互之间存在一种或多种特定关系的数据元素的集合")]),t._v(" "),_("li",[t._v("是一个二元组 -> ["),_("code",[t._v("形式定义")]),t._v("]\n"),_("ul",[_("li",[t._v("eg： Data_Structure = ( D , S )\nD ：是数据元素的有限集\t丨   S ：是D上关系的有限集")])])]),t._v(" "),_("li",[t._v("是从操作对象抽象出来的数学模型 -> ["),_("code",[t._v("数学描述")]),t._v("]")])])]),t._v(" "),_("li",[t._v("数据类型：一组性质相同的值的集合, 以及定义于这个值集合上的一组操作的总称。\n"),_("ul",[_("li",[t._v("原子类型：其值不可再分的数据类型 -> "),_("code",[t._v("值的集合+操作 [ int , char , float , etc . ]")])]),t._v(" "),_("li",[t._v("结构类型：其值可以再分解为若干成分（分量）的数据类型 -> "),_("code",[t._v("结构集合+操作 [list , map , etc . ]")])]),t._v(" "),_("li",[t._v("抽象数据类型：抽象数据组织及与之相关的操作 -> "),_("code",[t._v("数据对象 + 数据关系 + 操作")])])])])]),t._v(" "),_("h4",{attrs:{id:"逻辑结构"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#逻辑结构"}},[t._v("#")]),t._v(" "),_("strong",[t._v("逻辑结构")])]),t._v(" "),_("div",{staticClass:"language-bash extra-class"},[_("pre",{pre:!0,attrs:{class:"language-bash"}},[_("code",[_("span",{pre:!0,attrs:{class:"token string"}},[t._v("'Logical Structure & Storage Structure'")]),t._v("\n\n                ┌ 集合\n\t┌ 逻辑结构  —— 线性结构\n\t"),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v("\t\t    ├ 树形结构\n\t"),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v("           └ 图状结构 / 网状结构\nDS -"),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v("\n\t"),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v("\n\t"),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v("\t\t  \t┌ 顺序\n\t└ 物理结构  ·\n\t\t\t  \t└ 链式\n")])])]),_("div",{staticClass:"language-bash extra-class"},[_("pre",{pre:!0,attrs:{class:"language-bash"}},[_("code",[t._v(" \t          ┌ 一般线性表\n\t\t\t  "),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v("\t\t\t\t┌ 栈和队列\n\t┌ 线性结构—— 受限线性表  ·\n\t"),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v("\t\t  "),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v("\t\t        └ 串\n\t"),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v("\t\t  "),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v("\n\t"),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v("\t\t  "),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v("\t\t\t  ┌ 数组\n\t"),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v("         └ 线性表推广 ·\n\t"),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v("\t\t\t\t\t  └ 广义表\nDS -"),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v("\n\t"),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v("\n\t"),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v("\t\t    ┌ 集合\n\t"),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v("\t\t    "),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v("\n\t"),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v("\t\t    "),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v("\t\t  ┌ 一般树\n\t└ 非线性结构——树形结构 ·\n\t\t\t\t"),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v("\t\t  └ 二叉树\n\t\t\t\t"),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v("\n\t\t\t\t"),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v("\t\t   ┌ 有向图\n\t\t\t\t└ 图状结构 ·\n\t\t\t\t   \t\t   └ 无向图\n\t\t\t\t\t\t \nNote:\n"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),_("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" 线性结构: 有且只有一个开始与结束和一个终端结点\n"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),_("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" 非线性结构: 一个结点，可能有多个直接前驱和直接后继\n\n"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("逻辑结构"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" -"),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("算法设计"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n 映 ☟ 射\t\t  ☟\n"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("存储结构"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" -"),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("算法实践"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n")])])]),_("h4",{attrs:{id:"存储结构"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#存储结构"}},[t._v("#")]),t._v(" "),_("strong",[t._v("存储结构")])]),t._v(" "),_("p",[t._v("顺序映像：")]),t._v(" "),_("blockquote",[_("p",[t._v("以相对的存储位置表示后继关系")])]),t._v(" "),_("p",[t._v("链式映像：")]),t._v(" "),_("blockquote",[_("p",[t._v("以附加信息(指针)表示后继关系")])]),t._v(" "),_("table",[_("thead",[_("tr",[_("th",{staticStyle:{"text-align":"center"}},[t._v("表头")]),t._v(" "),_("th",{staticStyle:{"text-align":"center"}},[t._v("顺序存储结构")]),t._v(" "),_("th",{staticStyle:{"text-align":"center"}},[t._v("链式存储结构")])])]),t._v(" "),_("tbody",[_("tr",[_("td",{staticStyle:{"text-align":"center"}},[t._v("优点")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("存储密度大（＝1） 存储空间利用率高")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("插入或删除元素时很方便 使用灵活")])]),t._v(" "),_("tr",[_("td",{staticStyle:{"text-align":"center"}},[t._v("缺点")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("插入或删除元素时不方便")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("存储密度小（<1） 存储空间利用率低")])]),t._v(" "),_("tr",[_("td",{staticStyle:{"text-align":"center"}},[t._v("不同")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("顺序存储结构的内存地址一定是连续的")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("链表存储结构的内存地址不一定是连续的")])]),t._v(" "),_("tr",[_("td",{staticStyle:{"text-align":"center"}},[t._v("相同")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}}),t._v(" "),_("td",{staticStyle:{"text-align":"center"}})])])]),t._v(" "),_("h4",{attrs:{id:"适用情况"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#适用情况"}},[t._v("#")]),t._v(" "),_("strong",[t._v("适用情况")])]),t._v(" "),_("ul",[_("li",[t._v("顺序表适宜于做查找这样的静态操作；")]),t._v(" "),_("li",[t._v("链表宜于做插入、删除这样的动态操作。")]),t._v(" "),_("li",[t._v("若线性表的长度变化不大，且其主要操作是查找，则采用顺序表；")]),t._v(" "),_("li",[t._v("若线性表的长度变化较大，且其主要操作是插入、删除操作，则采用链表。")])]),t._v(" "),_("h4",{attrs:{id:"抽象数据类型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#抽象数据类型"}},[t._v("#")]),t._v(" 抽象数据类型")]),t._v(" "),_("ul",[_("li",[t._v("原子类型")]),t._v(" "),_("li",[t._v("固定聚合类型")]),t._v(" "),_("li",[t._v("可变聚合类型")])]),t._v(" "),_("p",[t._v("抽象数据类型可用（D, S, P）三元组表示。")]),t._v(" "),_("ul",[_("li",[t._v("D : 是数据对象；")]),t._v(" "),_("li",[t._v("S : 是 D 上的关系集；")]),t._v(" "),_("li",[t._v("P : 是对 D 的基本操作集。")])]),t._v(" "),_("h4",{attrs:{id:"抽象数据类型定义"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#抽象数据类型定义"}},[t._v("#")]),t._v(" 抽象数据类型定义")]),t._v(" "),_("div",{staticClass:"language-bash extra-class"},[_("pre",{pre:!0,attrs:{class:"language-bash"}},[_("code",[t._v("抽象数据类型的定义格式:\nADT 抽象数据类型名 "),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t数据对象: "),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("数据对象的定义"),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n\t数据关系: "),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("数据关系的定义"),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n\t基本操作: "),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("基本操作的定义"),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" ADT 抽象数据类型名 \n\n---------------------\n\n数据对象和数据关系的定义用伪代码描述\n\n基本操作的定义格式:\t\n基本操作名"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("参数表"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\t初始条件: "),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("初始条件描述"),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n\t操作结果: "),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("操作结果描述"),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n")])])]),_("p",[t._v("ADT：两个重要特点")]),t._v(" "),_("ul",[_("li",[t._v("数据抽象：\n用ADT描述程序处理的实体时，强调的是其本质的特征、其所能完成的功能以及它和外部用户的接口（即外界使用它的方法）。")]),t._v(" "),_("li",[t._v("数据封装：\n将实体的外部特性和其内部实现细节分离，并且对外部用户隐藏其内部实现细节。")])]),t._v(" "),_("h3",{attrs:{id:"_1-3-抽象数据类型的表示与实现"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-抽象数据类型的表示与实现"}},[t._v("#")]),t._v(" 1.3 抽象数据类型的表示与实现")]),t._v(" "),_("p",[t._v("[C/C++]")]),t._v(" "),_("h3",{attrs:{id:"_1-4-算法和算法分析"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-4-算法和算法分析"}},[t._v("#")]),t._v(" 1.4 算法和算法分析")]),t._v(" "),_("h4",{attrs:{id:"_1-4-1-算法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-4-1-算法"}},[t._v("#")]),t._v(" 1.4.1 算法")]),t._v(" "),_("p",[t._v("算法：是对特定问题求解步骤的一种描述，它是指令的有限序列，其中每一条指令表示一个或多个操作。")]),t._v(" "),_("p",[t._v("算法特征:")]),t._v(" "),_("ol",[_("li",[t._v("有穷性：一个算法必须总是（对任何合法的输入值）执行有穷步之后结束，且每一步都可以在有穷时间内完成。")]),t._v(" "),_("li",[t._v("确定性：算法中每一条指令必须有确切的含义，算法只有唯一的一条执行路径。")]),t._v(" "),_("li",[t._v("可行性：算法中描述的操作都是可以通过已经实现的基本运算执行有限次来实现的。")]),t._v(" "),_("li",[t._v("输入与输出")])]),t._v(" "),_("h4",{attrs:{id:"_1-4-2-算法设计的要求"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-4-2-算法设计的要求"}},[t._v("#")]),t._v(" 1.4.2 算法设计的要求")]),t._v(" "),_("ul",[_("li",[t._v('正确性："正确"一词的含义在通常的用法中有很大的差别，大体上可分为以下4个层次：\n'),_("ol",[_("li",[t._v("程序不含语法错误。")]),t._v(" "),_("li",[t._v("程序对于几组输入数据得出满足规格说明要求的结果。")]),t._v(" "),_("li",[t._v("程序对于精心选择的典型、苛刻而带有发难性的几组输入数据能够得出满足规格说明要求的结果。")]),t._v(" "),_("li",[t._v("程序对于一切合法的输入数据都能产生满足规格说明要求的结果。")])])])]),t._v(" "),_("p",[t._v("显然，达到第 4 层意义下的正确是极为困难的，所有不同输入数据的数量大得惊人，逐一验证的方法是不现实的。对于大型软件需要进行专业测试，而一般情况下，通常以第 3 层意义的正确性作为衡量一个程序是否合格的标准。")]),t._v(" "),_("ul",[_("li",[t._v("可读性")])]),t._v(" "),_("p",[t._v("算法主要是为了人的阅读与交流，其次才是机器执行。\n可读性好有助于人对算法牟理解；晦涩难懂的程序易于隐藏较多错误，难以调试和修改。")]),t._v(" "),_("ul",[_("li",[t._v("健壮性")])]),t._v(" "),_("p",[t._v("当输入数据非法时，算法也能适当地做出反应或进行处理，而不会产生黄晓明其妙的输出结果。例如，一个求凸多边形面积的算法，是采用求各三角形面积之和的策略来解决问题的。当输入的坐标集合表示的是一个凹多边形时，不应继续计算，而应报告输入出错。并且处理出错的方法应是返回一个表示错误或错误性质的值，而不是打印错误信息或异常，并中止程序的执行，以便在更高的抽象层次上进行处理。")]),t._v(" "),_("ul",[_("li",[t._v("效率与低存储量需求")])]),t._v(" "),_("p",[t._v("通俗地说，效率指的是算法执行的时间。对于同一个问题如果有多个算法可以解决，执行时间短的算法效率高。存储量需求算法执行过程中所需要的最大存储空间。效率与低存储量需求这两者都与问题的规模有关。求 100 个人的平均分与求 1000 个人的平均分所花的执行时间或运行空间显然有一空差别。")]),t._v(" "),_("h4",{attrs:{id:"_1-4-3算法效率的度量"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-4-3算法效率的度量"}},[t._v("#")]),t._v(" 1.4.3算法效率的度量")]),t._v(" "),_("ol",[_("li",[t._v("事后统计法：")])]),t._v(" "),_("ul",[_("li",[t._v("依据算法编写出程序，不同算法的程序可通过一组或若干组相同的测试数据，利用计算机内部的计时功能来分辨其优劣。")]),t._v(" "),_("li",[_("code",[t._v("缺陷")]),t._v(":\n"),_("ul",[_("li",[t._v("必须依据算法实现编制好测试程序")]),t._v(" "),_("li",[t._v("不同测试环境差别不是一般的大")])])])]),t._v(" "),_("ol",{attrs:{start:"2"}},[_("li",[t._v("事前分析估算法：")])]),t._v(" "),_("p",[t._v("通过对算法本身的分析，计算出算法的时间性能。\n消耗的时间取决于下列因素：")]),t._v(" "),_("ul",[_("li",[t._v("算法采用的策略和方案")]),t._v(" "),_("li",[t._v("编译产生的代码质量")]),t._v(" "),_("li",[t._v("问题的输入规模")]),t._v(" "),_("li",[t._v("机器执行指令的速度")])]),t._v(" "),_("h4",{attrs:{id:"_1-4-4-算法的存储空间需求"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-4-4-算法的存储空间需求"}},[t._v("#")]),t._v(" 1.4.4 算法的存储空间需求")]),t._v(" "),_("p",[t._v("一个算法的存储量包括形参所占空间和临时变量所占空间。\n在对算法进行存储空间分析时，只考察"),_("strong",[t._v("临时变量")]),t._v("所占空间。")]),t._v(" "),_("ul",[_("li",[t._v("算法的空间复杂度定义为: "),_("code",[t._v("S(n) = O( g(n) )")])]),t._v(" "),_("li",[t._v("表示随着问题规模 n 的增大，算法运行所需存储量的增长率与 g(n) 的增长率相同。")])]),t._v(" "),_("hr"),t._v(" "),_("h2",{attrs:{id:"补充"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#补充"}},[t._v("#")]),t._v(" 补充")]),t._v(" "),_("p",[t._v('数据结构中，一组数据中的每个个体被称为"数据元素"（简称"元素"）。'),_("br"),t._v('\n另外，对于具有"一对一"逻辑关系的数据，我们一直在用"某一元素的左侧（前边）或右侧（后边）"这样不专业的词，其实线性表中有更准确的术语：')]),t._v(" "),_("ul",[_("li",[t._v("某一元素的左侧相邻元素称为"),_("code",[t._v("直接前驱")]),t._v("，位于此元素左侧的所有元素都统称为"),_("code",[t._v("前驱元素")]),t._v(";")]),t._v(" "),_("li",[t._v("某一元素的右侧相邻元素称为"),_("code",[t._v("直接后继")]),t._v("，位于此元素右侧的所有元素都统称为"),_("code",[t._v("后继元素")]),t._v(";")])]),t._v(" "),_("h2",{attrs:{id:"课后练习"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#课后练习"}},[t._v("#")]),t._v(" 课后练习")]),t._v(" "),_("ul",[_("li",[t._v("以下属于逻辑结构的是（        ）."),_("br"),t._v("\nA：顺序表"),_("br"),t._v("\nB：哈希表"),_("br"),t._v("\nC：有序表"),_("br"),t._v("\nD：单链表"),_("br")]),t._v(" "),_("li",[t._v("以下与数据的存储结构无关的术语是（        ）."),_("br"),t._v("\nA：循环队列"),_("br"),t._v("\nB：链表"),_("br"),t._v("\nC：哈希表"),_("br"),t._v("\nD：栈"),_("br")]),t._v(" "),_("li",[t._v("以下关于数据结构的说法中，正确的是（        ）."),_("br"),t._v("\nA：数据的逻辑结构独立于其存储结构"),_("br"),t._v("\nB：数据的存储结构独立于其逻辑结构"),_("br"),t._v("\nC：数据的逻辑结构唯一决定了其存储结构"),_("br"),t._v("\nD：数据结构仅由其逻辑结构和存储结构决定"),_("br")]),t._v(" "),_("li",[t._v("链式存储设计时，结点内的存储单元地址（        ）."),_("br"),t._v("\nA：一定连续"),_("br"),t._v("\nB：一定不连续"),_("br"),t._v("\nC：不一定连续"),_("br"),t._v("\nD：部分连续，部分不连续"),_("br")]),t._v(" "),_("li",[t._v("与数据元素本身的形式、内容、相对位置、个数无关的是数据的（        ）.\t"),_("br"),t._v("\nA：存储结构"),_("br"),t._v("\nB：存储实现"),_("br"),t._v("\nC：逻辑结构"),_("br"),t._v("\nD：运算实现"),_("br")])])])}),[],!1,null,null,null);a.default=r.exports}}]);